@page "/Games/{GameId:guid}"
@using MinimalSetGame.Client.Entities
@using Card=MinimalSetGame.Client.Entities.Card
@inject IGamesHttpRepository GamesHttpRepository
@inject ISetHttpRepository SetHttpRepository
@inject ICardsHttpRepository CardsHttpRepository
@inject NavigationManager NavigationManager
@attribute [Authorize]

<PageTitle>Game</PageTitle>

<div class="container bg-light p-5 mb-5">
    <div class="row justify-content-center">
        @if (_gameResponse?.Deck is not null)
        {
            @foreach (var card in _gameResponse.Deck.Where(
                      c => c.IsDrawn &&
                           !_gameResponse.Sets.Any(
                           s => s.Cards.Contains(
                           c
                               .Id))))
            {
                <div class="col-auto m-2">
                    <Card CardResponse="@card" IsSelected="@IsCardSelected(card)"
                          OnCardSelected="OnCardClick">
                    </Card>
                </div>
            }
        }
        else
        {
            <div class="card text-center">
                No cards drawn yet
            </div>
        }
    </div>
</div>

<div class="container bg-light p-5">
    <ul>
        <li>Cards: @_gameResponse?.Deck?.Count</li>
        <li>Drawn cards: @_gameResponse?.Deck?.FindAll(c => c.IsDrawn).Count</li>
        <li>Sets: @_gameResponse?.Sets.Count</li>
    </ul>
</div>

@code {

    List<CardResponse> _selectedCards = [];

//todo: Map gamerResponse to game and the rest of the entities. So i can use the entities instead of the responses, this should fix the issue with the selected cards and the layout not updating
    List<Card> _cards = []; // This is the list of cards that are drawn and not in a set
    List<Set>  _sets = [];


    [Parameter]
    public Guid GameId { get; set; }

    private GameResponse? _gameResponse;

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
        _gameResponse = await GamesHttpRepository.GetGameById(GameId);

        if (_gameResponse is null)
            NavigationManager.NavigateTo("games");

        var totalCards = _gameResponse?.Deck.Count ?? 0;
        const int initialAmountOfCards = 12;
        var drawnCardsNotInSet = _gameResponse?.Deck.Where(
                                     c => c.IsDrawn &&
                                          !_gameResponse.Sets.Any(s => s.Cards.Contains(c.Id)))
                                     .ToList()
                                     .Count ??
                                 0;

        if (drawnCardsNotInSet < initialAmountOfCards)
        {
            await CardsHttpRepository.DrawCards(GameId, initialAmountOfCards - drawnCardsNotInSet);
            _gameResponse = await GamesHttpRepository.GetGameById(GameId);
        }
    }

    private void OnCardClick(CardResponse card)
    {
        if (IsCardSelected(card))
        {
            _selectedCards.Remove(card);
        }
        else
        {
            _selectedCards.Add(card);
        }

        if (_selectedCards.Count == 3)
        {
            TryAddSet();
        }
    }

    async void TryAddSet()
    {
        var request =
            new CreateSetRequest(
            GameId,
            _selectedCards.Select(c => c.Id).ToList());

        await SetHttpRepository.TryCreateSet(GameId, request);

        _selectedCards.Clear();
        _gameResponse = await GamesHttpRepository.GetGameById(GameId);
        StateHasChanged();
    }

    private bool IsCardSelected(CardResponse card) { return _selectedCards.Contains(card); }
}
